#!/bin/sh

#####################
# -- config vars -- #
#####################

# seconds to wait before suspend
delay_suspend=900

suspend_on_ac=1

if [ -r "$CONF" ]; then
    # yes, we just outright source the config file without caring...
    # you can only override things written before this, so no arbitrary
    # functions from config
    . "$CONF"
fi

#####################
# --- variables --- #
#####################

# type:        string
# description
#   script base name through the idiom "${0##*/}"
myname="${0##*/}"

# type:        int
# description
#   current running pid of the script
mypid="$$"

NO_CONTINUE=""
dbgOUT=""
VERB=""
watch_pid=""

# 1000 milliseconds
one_second=1000

# 4 cycles per second
cycles=4

# one_second / cycles
cycle_time=$(( one_second / cycles ))

count=$(( delay_suspend * cycles ))

# type: int
# value: 0
# description: unix shell style boolean
btrue=0
# type: int
# value: 1
# description: unix shell style boolean
bfalse=1


# return type: boolean
# usage: is_int "value"
# description: check if passed value is a number
is_int() {
    if [ -n "$1" ]; then
        printf %d "$1" >/dev/null 2>&1
    else
        return $bfalse
    fi
}

# thin awk wrapper that will prefer mawk over gawk
u_awk () { awk "$@"; }
if command -v mawk >/dev/null; then
    u_awk () { mawk "$@"; }
fi

# usage: pid_tree_search PID NAME
#      PID: the parent pid among whose ps tree we will search
#     NAME: the name of the program whose pid we want
# return type: integer
# return error: standard error return value 1
pid_tree_search () {
    search_pid="$1"
    search_name="$2"
    word_length="${#search_name}"
    rval=$(
        pstree -Aps "${search_pid}" 2>/dev/null \
        | u_awk \
            -v name="$search_name" \
            -v wlen="$word_length" \
            '\
                BEGIN { search=name"\\([[:digit:]]*\\)" } \
                match( $0, search )\
                {\
                    print substr($0,RSTART+wlen+1,RLENGTH-wlen-2) \
                }\
            '
        )
    if is_int "$rval"; then
        printf '%s\n' "$rval"
    else
        return $bfalse
    fi
}

# Usage: write_log "message text"
# Return: void
# Description:
#   Write message to log file
write_log () {
    name="$myname"
    message="$*"
    printf '[%s] %12s %*s: %s\n' \
        "$(date +'%Y-%m-%d %H:%M:%S')" \
        "$name" \
        "$PIDWIDTH" "[$mypid]" \
        "$message" \
        >> "$LOGFILE"
}

# usage: msleep int
# description: sleep for milliseconds
# return type: void
msleep () {
    milisecs="$1"
    if [ -n "$has_usleep" ]; then
        microsecs="${milisecs}000"
        case "$has_usleep" in
            */usleep)
                usleep "$microsecs"
                ;;
            */busybox)
                busybox usleep "$microsecs"
                ;;
        esac
    else
        secs=$(awk -v s="${milisecs}" 'BEGIN {printf "%.3f", s/1000}')
        sleep "$secs"
    fi
}

do_suspend () {
    if [ -x "$(command -v systemact)" ]; then
        systemact -N sleep
    fi
}

sig_handler() {
    NO_CONTINUE=1
    if [ -n "$dbgOUT" ] || [ -n "$VERB" ]; then
        printf "\n[%s] %s: received signal %s, terminating.\n" \
            "$(date +"%F %T")" "${myname}" "$1"
    fi
}

can_suspend() {
    # |on_ac_power|suspend_on_ac|suspend|
    # |     T     |     T       |   T   |
    # |     T     |     F       |   F   |
    # |     F     |     T       |   T   |
    # |     F     |     F       |   T   |
    if [ "$suspend_on_ac" -eq "$btrue" ] && on_ac_power; then
        if [ -n "$dbgOUT" ] || [ -n "$VERB" ]; then
            echo "suspend on ac is: $suspend_on_ac"
            echo "returning $btrue"
        fi
        return $btrue
    else
        if on_ac_power; then
            if [ -n "$dbgOUT" ] || [ -n "$VERB" ]; then
                echo "on ac power is: $btrue"
                echo "returning $bfalse"
            fi
            return $bfalse
        else
            if [ -n "$dbgOUT" ] || [ -n "$VERB" ]; then
                echo "on ac power is: $bfalse"
                echo "returning $btrue"
            fi
            return $btrue
        fi
    fi
}

while [ $# -gt 0 ]; do
    case $1 in
        -debug)
            dbgOUT=1
        ;;
        -verbose)
            VERB=1
        ;;
        "help"|"-help"|"--help"|"-h")
            # show_help
            exit $btrue
        ;;
        -watch)
            shift
            if is_int "$1"; then
                watch_pid=$1
            fi
        ;;
        *)
            printf '%s: %s\n' "$myname" \
                "unknown argument '${1}'"
            # show_usage
            exit $bfalse
        ;;
    esac
    shift
done

trap 'sig_handler TERM' TERM
trap 'sig_handler INT' INT
trap 'sig_handler HUP' HUP
trap 'sig_handler USR1' USR1
trap 'sig_handler USR2' USR2

c=0
while [ -z "$NO_CONTINUE" ]; do
    if [ -n "$watch_pid" ]; then
        if [ -n "$dbgOUT" ] || [ -n "$VERB" ]; then
            echo "watching pid $watch_pid"
        fi
        if ! pid_tree_search "$watch_pid" "$myname" >/dev/null ; then
            c=0
            NO_CONTINUE=1
            if [ -n "$dbgOUT" ] || [ -n "$VERB" ]; then
                echo "preparing to exit"
            fi
        fi
    fi
    if [ "$c" = "$count" ]; then
        c=0
        if can_suspend; then
            if [ -n "$dbgOUT" ] || [ -n "$VERB" ]; then
                echo "can suspend"
            fi
            do_suspend
        else
            if [ -n "$dbgOUT" ] || [ -n "$VERB" ]; then
                echo "cannot suspend"
            fi
        fi
    fi
    c=$(( c + 1))
    if [ -n "$VERB" ]; then
        printf '%s: %3d\n' "$myname" "$c"
    fi
    msleep "$cycle_time"
done
